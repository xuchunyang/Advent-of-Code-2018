#+TITLE: Advent of Code 2018 in Emacs Lisp

#+PROPERTY: header-args:elisp :lexical t

* Table of Contents                                               :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#day-1-chronal-calibration][Day 1: Chronal Calibration]]
  - [[#part-one][Part One]]
  - [[#part-two][Part Two]]
- [[#day-2-inventory-management-system][Day 2: Inventory Management System]]
  - [[#part-one-1][Part one]]
  - [[#part-two-1][Part Two]]
- [[#day-3-no-matter-how-you-slice-it][Day 3: No Matter How You Slice it]]
  - [[#part-one-2][Part One]]
  - [[#part-two-2][Part Two]]
#+END_QUOTE

* Day 1: Chronal Calibration

** Part One

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-1 (input-file)
  (interactive "fInput file: ")
  (with-temp-buffer
    (insert-file-contents input-file)
    (goto-char (point-min))
    (let ((frequency 0)
          change)
      (while (setq change (ignore-errors (read (current-buffer))))
        (setq frequency (+ frequency change)))
      (kill-new (format "%d" frequency))
      (message "Copied: %d" frequency))))
#+END_SRC

** Part Two

#+NAME: tb1
| Changes            | Answer |
|--------------------+--------|
| +1, -1             |      0 |
| +3, +3, +4, -2, -4 |     10 |
| -6, +3, +8, +5, -6 |      5 |
| +7, +7, -2, -7, -4 |     14 |

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-2-subr (changes)
  (let ((frequencies (list 0))
        (cursor changes)
        frequency)
    (catch 'found
      (while t
        (setq frequency (+ (car frequencies) (car cursor)))
        (when (memq frequency frequencies)
          (throw 'found frequency))
        (push frequency frequencies)
        (setq cursor (or (cdr cursor) changes))))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-1-2-subr

Test the function against the above table:

#+BEGIN_SRC elisp :var data=tb1[,0]
(let ((list-of-changes
       (mapcar (lambda (s)
                 (mapcar #'string-to-number (split-string s ", " t)))
               data)))
  (mapcar #'advent-of-code-2018-1-2-subr list-of-changes))
#+END_SRC

#+RESULTS:
| 0 | 10 | 5 | 14 |

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-2 (input-file)
  (interactive "fInput file: ")
  (let* ((changes
          (with-temp-buffer
            (insert-file-contents input-file)
            (mapcar #'string-to-number
                    (split-string (buffer-string) "\n" 'omit-nulls))))
         (frequency
          (advent-of-code-2018-1-2-subr changes)))
    (kill-new (format "%d" frequency))
    (message "Copied: %d" frequency)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-1-2

It takes 48.060945s with my input file.

* Day 2: Inventory Management System

** Part one

#+NAME: day2-tb1
| ID     |
|--------|
| abcdef |
| bababc |
| abbcde |
| abcccd |
| aabcdd |
| abcdee |
| ababab |

#+BEGIN_SRC elisp :var data=day2-tb1[,0] :results pp
(let ((twos 0)
      (threes 0))
  (dolist (input data)
    (let ((lst (string-to-list input)))
      (when (cl-find-if (lambda (item)
                          (= 2 (cl-count item lst)))
                        lst)
        (cl-incf twos))
      (when (cl-find-if (lambda (item)
                          (= 3 (cl-count item lst)))
                        lst)
        (cl-incf threes))))
  (* twos threes))
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-1 (input-file)
  (interactive "fInput File: ")
  (let ((input-lines
         (with-temp-buffer
           (insert-file-contents input-file)
           (split-string (buffer-string) "\n" 'omit-nulls))))
    (let ((twos 0)
          (threes 0))
      (dolist (input input-lines)
        (let ((lst (string-to-list input)))
          (when (cl-find-if (lambda (item)
                              (= 2 (cl-count item lst)))
                            lst)
            (cl-incf twos))
          (when (cl-find-if (lambda (item)
                              (= 3 (cl-count item lst)))
                            lst)
            (cl-incf threes))))
      (message "Answer: %s" (* twos threes)))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-1

** Part Two

helper 1

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2-combinations (list)
  (let ((i 0)
        result)
    (while (< i (length list))
      (let ((j (1+ i)))
        (while (< j (length list))
          (push (cons (nth i list)
                      (nth j list))
                result)
          (cl-incf j)))
      (cl-incf i))
    (nreverse result)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2-combinations

test helper 1

#+BEGIN_SRC elisp
(advent-of-code-2018-2-2-combinations '(a b c))
#+END_SRC

#+RESULTS:
: ((a . b) (a . c) (b . c))

helper 2

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2-subr (ids)
  (cl-some
   (pcase-lambda (`(,id1 . ,id2))
     (cl-assert (= (length id1) (length id2)))
     (let ((diffs 0) pos)
       (dotimes (i (length id1))
         (when (/= (elt id1 i) (elt id2 i))
           (setq pos i)
           (cl-incf diffs)))
       (when (= diffs 1)
         (concat (substring id1 0 pos)
                 (substring id1 (1+ pos))))))
   (advent-of-code-2018-2-2-combinations ids)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2-subr

test helper 2

#+NAME: day2-tb2
| ID    |
|-------|
| abcde |
| fghij |
| klmno |
| pqrst |
| fguij |
| axcye |
| wvxyz |

#+BEGIN_SRC elisp :var data=day2-tb2[,0]
(advent-of-code-2018-2-2-subr data)
#+END_SRC

#+RESULTS:
: fgij

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2 (input-file)
  (interactive "fInput File: ")
  (let ((input-lines
         (with-temp-buffer
           (insert-file-contents input-file)
           (split-string (buffer-string) "\n" 'omit-nulls))))
    (message "Answer: %s" (advent-of-code-2018-2-2-subr input-lines))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2

* Day 3: No Matter How You Slice it

** Part One

#+NAME: day3-table-1
| #1 @ 1,3: 4x4 |
| #2 @ 3,1: 4x4 |
| #3 @ 5,5: 2x2 |

Parse input

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-1-parse (inputs)
  (let ((regexp (replace-regexp-in-string
                 "_"
                 (rx (group (1+ num)))
                 ;; #1 @ 1,3: 4x4
                 "#_ @ _,_: _x_"
                 nil
                 'literal)))
    (mapcar (lambda (s)
              (cl-assert (string-match regexp s))
              (list :id   (string-to-number (match-string 1 s))
                    :left (string-to-number (match-string 2 s))
                    :top  (string-to-number (match-string 3 s))
                    :wide (string-to-number (match-string 4 s))
                    :tall (string-to-number (match-string 5 s))))
            inputs)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-1-parse

#+BEGIN_SRC elisp :var data=day3-table-1[,0]
(advent-of-code-2018-3-1-parse data)
#+END_SRC

#+RESULTS:
| :id | 1 | :left | 1 | :top | 3 | :wide | 4 | :tall | 4 |
| :id | 2 | :left | 3 | :top | 1 | :wide | 4 | :tall | 4 |
| :id | 3 | :left | 5 | :top | 5 | :wide | 2 | :tall | 2 |

Area

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-1-area (data)
  (list :width
        (apply #'max
               (mapcar (lambda (pl)
                         (+ (plist-get pl :left)
                            (plist-get pl :wide)))
                       data))
        :height
        (apply #'max
               (mapcar (lambda (pl)
                         (+ (plist-get pl :top)
                            (plist-get pl :tall)))
                       data))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-1-area

#+BEGIN_SRC elisp :var data=day3-table-1[,0]
(advent-of-code-2018-3-1-area (advent-of-code-2018-3-1-parse data))
#+END_SRC

#+RESULTS:
| :width | 7 | :height | 7 |

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-1-make-vector (width height)
  (let ((vec (make-vector height nil)))
    (dotimes (i height vec)
      (setf (elt vec i) (make-vector width 0)))))

(defun advent-of-code-2018-3-1-subr (inputs)
  (let* ((claims (advent-of-code-2018-3-1-parse inputs))
         (area (advent-of-code-2018-3-1-area claims))
         (height (plist-get area :height))
         (width (plist-get area :width))
         (vv (advent-of-code-2018-3-1-make-vector width height)))
    (dolist (claim claims)
      (let ((x (plist-get claim :left))
            (y (plist-get claim :top)))
        (dotimes (i (plist-get claim :wide))
          (dotimes (j (plist-get claim :tall))
            (cl-incf (elt (elt vv (+ y j)) (+ x i)))))))
    (let ((count 0))
      (dotimes (i width count)
        (dotimes (j height)
          (when (> (elt (elt vv i) j) 1)
            (cl-incf count)))))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-1-subr

#+BEGIN_SRC elisp :var inputs=day3-table-1[,0]
(advent-of-code-2018-3-1-subr inputs)
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-1 (input-file)
  (interactive "fInput file: ")
  (let ((input-lines
         (with-temp-buffer
           (insert-file-contents input-file)
           (split-string (buffer-string) "\n" t))))
    (message "Answer: %s" (advent-of-code-2018-3-1-subr input-lines))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-1

** Part Two

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-2-overlap-p (claim vv)
  (let ((x (plist-get claim :left))
        (y (plist-get claim :top)))
    (catch 'overlap
      (dotimes (i (plist-get claim :wide))
        (dotimes (j (plist-get claim :tall))
          (when (> (elt (elt vv (+ y j)) (+ x i)) 1)
            (throw 'overlap t)))))))

(defun advent-of-code-2018-3-2-subr (inputs)
  (let* ((claims (advent-of-code-2018-3-1-parse inputs))
         (area (advent-of-code-2018-3-1-area claims))
         (height (plist-get area :height))
         (width (plist-get area :width))
         (vv (advent-of-code-2018-3-1-make-vector width height)))
    (dolist (claim claims)
      (let ((x (plist-get claim :left))
            (y (plist-get claim :top)))
        (dotimes (i (plist-get claim :wide))
          (dotimes (j (plist-get claim :tall))
            (cl-incf (elt (elt vv (+ y j)) (+ x i)))))))
    (let ((claim
           (cl-find-if-not
            (lambda (claim)
              (advent-of-code-2018-3-2-overlap-p claim vv))
            claims)))
      (cl-assert claim)
      (plist-get claim :id))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-2-subr

#+BEGIN_SRC elisp :var inputs=day3-table-1[,0]
(advent-of-code-2018-3-2-subr inputs)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(defun advent-of-code-2018-3-2 (input-file)
  (interactive "fInput file: ")
  (message
   "Answer: %s"
   (advent-of-code-2018-3-2-subr
    (with-temp-buffer
      (insert-file-contents input-file)
      (split-string (buffer-string) "\n" t)))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-3-2

#+BEGIN_SRC elisp
(advent-of-code-2018-3-2 "inputs/3-2.txt")
#+END_SRC

#+RESULTS:
: Answer: 331
