#+TITLE: Advent of Code 2018 in Emacs Lisp

#+PROPERTY: header-args:elisp :lexical t

* Day 1: Chronal Calibration

** Part One

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-1 (input-file)
  (interactive "fInput file: ")
  (with-temp-buffer
    (insert-file-contents input-file)
    (goto-char (point-min))
    (let ((frequency 0)
          change)
      (while (setq change (ignore-errors (read (current-buffer))))
        (setq frequency (+ frequency change)))
      (kill-new (format "%d" frequency))
      (message "Copied: %d" frequency))))
#+END_SRC

** Part Two

#+NAME: tb1
| Changes            | Answer |
|--------------------+--------|
| +1, -1             |      0 |
| +3, +3, +4, -2, -4 |     10 |
| -6, +3, +8, +5, -6 |      5 |
| +7, +7, -2, -7, -4 |     14 |

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-2-subr (changes)
  (let ((frequencies (list 0))
        (cursor changes)
        frequency)
    (catch 'found
      (while t
        (setq frequency (+ (car frequencies) (car cursor)))
        (when (memq frequency frequencies)
          (throw 'found frequency))
        (push frequency frequencies)
        (setq cursor (or (cdr cursor) changes))))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-1-2-subr

Test the function against the above table:

#+BEGIN_SRC elisp :var data=tb1[,0]
(let ((list-of-changes
       (mapcar (lambda (s)
                 (mapcar #'string-to-number (split-string s ", " t)))
               data)))
  (mapcar #'advent-of-code-2018-1-2-subr list-of-changes))
#+END_SRC

#+RESULTS:
| 0 | 10 | 5 | 14 |

#+BEGIN_SRC elisp
(defun advent-of-code-2018-1-2 (input-file)
  (interactive "fInput file: ")
  (let* ((changes
          (with-temp-buffer
            (insert-file-contents input-file)
            (mapcar #'string-to-number
                    (split-string (buffer-string) "\n" 'omit-nulls))))
         (frequency
          (advent-of-code-2018-1-2-subr changes)))
    (kill-new (format "%d" frequency))
    (message "Copied: %d" frequency)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-1-2

It takes 48.060945s with my input file.

* Day 2: Inventory Management System

** Part one

#+NAME: day2-tb1
| ID     |
|--------|
| abcdef |
| bababc |
| abbcde |
| abcccd |
| aabcdd |
| abcdee |
| ababab |

#+BEGIN_SRC elisp :var data=day2-tb1[,0] :results pp
(let ((twos 0)
      (threes 0))
  (dolist (input data)
    (let ((lst (string-to-list input)))
      (when (cl-find-if (lambda (item)
                          (= 2 (cl-count item lst)))
                        lst)
        (cl-incf twos))
      (when (cl-find-if (lambda (item)
                          (= 3 (cl-count item lst)))
                        lst)
        (cl-incf threes))))
  (* twos threes))
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-1 (input-file)
  (interactive "fInput File: ")
  (let ((input-lines
         (with-temp-buffer
           (insert-file-contents input-file)
           (split-string (buffer-string) "\n" 'omit-nulls))))
    (let ((twos 0)
          (threes 0))
      (dolist (input input-lines)
        (let ((lst (string-to-list input)))
          (when (cl-find-if (lambda (item)
                              (= 2 (cl-count item lst)))
                            lst)
            (cl-incf twos))
          (when (cl-find-if (lambda (item)
                              (= 3 (cl-count item lst)))
                            lst)
            (cl-incf threes))))
      (message "Answer: %s" (* twos threes)))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-1

** Part Two

helper 1

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2-combinations (list)
  (let ((i 0)
        result)
    (while (< i (length list))
      (let ((j (1+ i)))
        (while (< j (length list))
          (push (cons (nth i list)
                      (nth j list))
                result)
          (cl-incf j)))
      (cl-incf i))
    (nreverse result)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2-combinations

test helper 1

#+BEGIN_SRC elisp
(advent-of-code-2018-2-2-combinations '(a b c))
#+END_SRC

#+RESULTS:
: ((a . b) (a . c) (b . c))

helper 2

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2-subr (ids)
  (cl-some
   (pcase-lambda (`(,id1 . ,id2))
     (cl-assert (= (length id1) (length id2)))
     (let ((diffs 0) pos)
       (dotimes (i (length id1))
         (when (/= (elt id1 i) (elt id2 i))
           (setq pos i)
           (cl-incf diffs)))
       (when (= diffs 1)
         (concat (substring id1 0 pos)
                 (substring id1 (1+ pos))))))
   (advent-of-code-2018-2-2-combinations ids)))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2-subr

test helper 2

#+NAME: day2-tb2
| ID    |
|-------|
| abcde |
| fghij |
| klmno |
| pqrst |
| fguij |
| axcye |
| wvxyz |

#+BEGIN_SRC elisp :var data=day2-tb2[,0]
(advent-of-code-2018-2-2-subr data)
#+END_SRC

#+RESULTS:
: fgij

#+BEGIN_SRC elisp
(defun advent-of-code-2018-2-2 (input-file)
  (interactive "fInput File: ")
  (let ((input-lines
         (with-temp-buffer
           (insert-file-contents input-file)
           (split-string (buffer-string) "\n" 'omit-nulls))))
    (message "Answer: %s" (advent-of-code-2018-2-2-subr input-lines))))
#+END_SRC

#+RESULTS:
: advent-of-code-2018-2-2
